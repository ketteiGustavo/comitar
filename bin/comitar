#!/usr/bin/env bash
################################################################################
# comitar - Commit sem√¢ntico com configura√ß√£o din√¢mica, changelog autom√°tico e hook integrado
#
# DATA: 25/07/2025 - Versao 0.0.3
# -------------------------------------------------------------------------------
# Autor: Luiz Gustavo <luizg.devlx@gmail.com>
# -------------------------------------------------------------------------------
# Controle de Vers√£o:
##  - Consultar CHANGELOG.md do projeto
################################################################################

set -e

CONFIG_FILE=".comitar.json"
CHANGELOG_FILE=""
INSTALL_DIR="$HOME/.local/bin"

readonly APP_VERSION="0.1.2"
readonly APP_DATE="26/09/2025"
readonly SCRIPT_NAME="$(basename "$0")"
readonly WORK_DIR="$(pwd)"
readonly COMITAR_INSTALL_ROOT="$HOME/.comitar"
readonly COMMIT_HOOK_SCRIPT="$COMITAR_INSTALL_ROOT/hooks/commit-check"
readonly TOOLS_DIR="$COMITAR_INSTALL_ROOT/tools"
readonly CHANGELOG_SCRIPT="$TOOLS_DIR/changelog.sh"
readonly UNINSTALL_SCRIPT="$TOOLS_DIR/uninstall.sh"
readonly UPGRADE_SCRIPT="$TOOLS_DIR/upgrade.sh"

check_git_repo_silent() {
  git rev-parse --is-inside-work-tree &>/dev/null
}


test_colors() {
  local use_colors_config=$(jq -r '.use_colors' "$CONFIG_FILE")
  local use_blinks_config=$(jq -r '.use_blinks' "$CONFIG_FILE")
  if [ "$(tput colors 2>/dev/null)" -ge 8 ] && [[ "$use_colors_config" == "true" ]] ; then
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    GRAY="\e[37m"
    BOLD="\e[1m"
    NC="\e[0m"   # no_color
  else
    USE_COLORS=0
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    MAGENTA=""
    CYAN=""
    GRAY=""
    BOLD=""
    NC=""
  fi
  if [ "$(tput colors 2>/dev/null)" -ge 8 ] && [[ "$use_blinks_config" == "true" ]] ; then
    BLINK="\e[5m"
  else
    BLINK=""
  fi
}


show_version() {
    printf "Vers√£o: %s - %s\n" "$APP_VERSION" "$APP_DATE"
}

show_help() {
    printf "${BLUE}${BOLD} %s${NC} - Commits padronizados com Conventional Commits + Hook\n\n" "$SCRIPT_NAME"
    printf "USO:\n"
    printf "  %s [op√ß√µes]\n\n" "$SCRIPT_NAME"
    printf "OP√á√ïES:\n"
    printf "  --init             Inicializa repo: git init, README, remoto e push\n"
    printf "  --install-hook     Instala o hook 'commit-msg' no reposit√≥rio atual\n"
    printf "  --commit           Abre menu para gerar commit sem√¢ntico com emoji\n"
    printf "  --changelog        Gera o changelog do projeto\n"
    printf "  --upgrade          Atualiza o comitar para a vers√£o mais recente\n"
    printf "  --uninstall        Desinstala o comitar\n"
    printf "  --news             Mostra as novidades do comitar\n"
    printf "  --help    | -h     Exibe esta ajuda\n"
    printf "  --version | -V     Exibe a vers√£o do utilit√°rio\n"
    printf "  --config  | -c     Abre menu interativo de configura√ß√µes\n"
    printf "  --undo             Desfaz o √∫ltimo commit localmente ou reverte se j√° enviado\n"

}

# Detecta se √© repo HTTPS ou SSH e normaliza .git se faltar.
detect_and_normalize_remote_url() {
  local input="$1"
  local url="$input"
  local kind=""

  # Aceita:
  #  SSH scp-like: git@github.com:org/repo(.git)?
  #  SSH scheme:   ssh://git@github.com/org/repo(.git)?
  #  HTTPS:        https://github.com/org/repo(.git)?
  case "$url" in
    git@*:* ) kind="ssh" ;;
    ssh://git@* ) kind="ssh" ;;
    https://* ) kind="https" ;;
    * )
      echo -e "${RED}‚ùå URL remota inv√°lida...${NC}"
      return 2
      ;;
  esac

  [[ $url != *.git ]] && url="${url}.git"
  echo "$kind|$url"

}

ensure_git_repo() {
  # se j√° for repo, n√£o faz nada
  if check_git_repo_silent; then
    return
  fi

  echo -e "${YELLOW}‚ö† Este diret√≥rio ainda n√£o √© um reposit√≥rio Git.${NC}"
  if ! confirm_default_yes "Deseja inicializar um reposit√≥rio Git aqui?"; then
    echo -e "${RED}‚ùå Opera√ß√£o cancelada porque n√£o h√° reposit√≥rio Git.${NC}"
    exit 1
  fi

  # branch padr√£o
  local default_branch
  default_branch="$(git config --global init.defaultBranch 2>/dev/null || true)"
  [[ -z "$default_branch" ]] && default_branch="main"

  read -rp "Nome da branch padr√£o (enter para '${default_branch}'): " user_branch
  [[ -n "$user_branch" ]] && default_branch="$user_branch"

  git init -b "$default_branch" && echo -e "${GREEN}‚úî Git inicializado (branch: ${default_branch}).${NC}"

  # .gitignore m√≠nimo -> .comitar.json ignorado
  if [[ ! -f ".gitignore" ]]; then
    echo "# Comitar config file" >> .gitignore
    echo ".comitar.json" >> .gitignore
    echo -e "${GREEN}‚úî .gitignore criado.${NC}"
  else
    grep -qE '(^|/)\.comitar\.json$' .gitignore || { echo ".comitar.json" >> .gitignore; echo -e "${GREEN}‚úî '.comitar.json' adicionado ao .gitignore.${NC}"; }
  fi

  # commit inicial (se houver algo)
  git add -A
  if ! git diff --cached --quiet; then
    git commit -m "chore: initial commit"
    echo -e "${GREEN}‚úî Commit inicial criado.${NC}"
  else
    echo -e "${YELLOW}‚Ñπ Nada para commitar no momento (reposit√≥rio vazio).${NC}"
  fi
}
# Garante que user.name e user.email est√£o definidos (repo > global)
ensure_git_identity() {
  local scope="--local"
  if ! check_git_repo_silent; then scope="--global"; fi

  # Pega valores efetivos (considera local e global)
  local name email
  name="$(git config --get user.name || true)"
  email="$(git config --get user.email || true)"

  if [[ -z "$name" ]]; then
    read -rp "Informe seu nome para o Git (ex: Luiz Gustavo): " name
    [[ -z "$name" ]] && { echo -e "${RED}‚ùå Nome n√£o pode ser vazio.${NC}"; exit 1; }
    git config $scope user.name "$name"
    echo -e "${GREEN}‚úî user.name configurado (${scope}).${NC}"
  fi

  if [[ -z "$email" ]]; then
    read -rp "Informe seu e-mail do Git (ex: seu-email@dominio): " email
    [[ -z "$email" ]] && { echo -e "${RED}‚ùå E-mail n√£o pode ser vazio.${NC}"; exit 1; }
    git config $scope user.email "$email"
    echo -e "${GREEN}‚úî user.email configurado (${scope}).${NC}"
  fi
}

# Verifica autentica√ß√£o SSH com GitHub (chave, agent e teste com ssh -T)
ensure_github_ssh_auth() {
  # 1) chave
  local ssh_key=""
  if [[ -f "$HOME/.ssh/id_ed25519" ]]; then ssh_key="$HOME/.ssh/id_ed25519"
  elif [[ -f "$HOME/.ssh/id_rsa" ]]; then ssh_key="$HOME/.ssh/id_rsa"
  fi

  if [[ -z "$ssh_key" ]]; then
    echo -e "${YELLOW}‚ö† Nenhuma chave SSH padr√£o encontrada (~/.ssh/id_ed25519 ou id_rsa).${NC}"
    if confirm_default_yes "Gerar nova chave ed25519 agora?"; then
      read -rp "E-mail para o r√≥tulo da chave (sugest√£o: $(git config user.email)): " keymail
      [[ -z "$keymail" ]] && keymail="$(git config user.email)"
      ssh-keygen -t ed25519 -C "$keymail"
      ssh_key="$HOME/.ssh/id_ed25519"
      echo -e "${GREEN}‚úî Chave criada.${NC}"
    else
      echo -e "${RED}‚ùå Sem chave SSH. Configure antes de continuar.${NC}"
      return 1
    fi
  fi

  # 2) agent
  if [[ -z "$SSH_AUTH_SOCK" ]]; then
    eval "$(ssh-agent -s)" >/dev/null
  fi
  ssh-add "$ssh_key" >/dev/null 2>&1 || true

  # 3) teste
  echo -e "${CYAN}üîê Testando SSH com GitHub (ssh -T git@github.com)...${NC}"
  if ssh -T git@github.com -o StrictHostKeyChecking=accept-new 2>&1 | grep -qiE "success|authenticated|Hi "; then
    echo -e "${GREEN}‚úî Autentica√ß√£o SSH com GitHub OK.${NC}"
    return 0
  else
    echo -e "${YELLOW}‚Ñπ N√£o foi poss√≠vel autenticar via SSH agora.${NC}"
    echo -e "   1) Adicione a sua chave p√∫blica no GitHub (Settings ‚ñ∏ SSH and GPG keys):"
    echo -e "      ${BOLD}$( [[ -f "${ssh_key}.pub" ]] && cat "${ssh_key}.pub" || echo "~/.ssh/id_ed25519.pub" )${NC}"
    echo -e "   2) Depois, rode novamente."
    return 1
  fi
}

# Verifica autentica√ß√£o HTTPS com GitHub (prioriza GitHub CLI)
ensure_github_https_auth() {
  if command -v gh >/dev/null 2>&1; then
    if gh auth status >/dev/null 2>&1; then
      echo -e "${GREEN}‚úî GitHub CLI autenticado (HTTPS).${NC}"
      return 0
    else
      echo -e "${YELLOW}‚Ñπ GitHub CLI n√£o autenticado.${NC}"
      if confirm_default_yes "Fazer login com 'gh auth login' agora?"; then
        gh auth login
        if gh auth status >/dev/null 2>&1; then
          echo -e "${GREEN}‚úî Autenticado com gh.${NC}"; return 0
        fi
      fi
    fi
  fi

  echo -e "${YELLOW}‚ö† gh n√£o dispon√≠vel ou n√£o autenticado.${NC}"
  echo -e "   Op√ß√µes:"
  echo -e "   ‚Ä¢ Instale e use ${BOLD}GitHub CLI (gh)${NC} para login seguro"
  echo -e "   ‚Ä¢ OU configure um ${BOLD}Personal Access Token (classic or fine-grained)${NC}"
  echo -e "     com escopo 'repo' e um helper de credenciais (ex.: git-credential-manager-core)."
  return 1
}

# Configura 'origin' pedindo a URL e testando acesso (ls-remote)
configure_remote_origin() {
  ensure_git_identity

  if git config --get remote.origin.url >/dev/null 2>&1; then
    #echo -e "${GREEN}‚úî Remoto 'origin' j√° configurado.${NC}"
    return 0
  fi

  if ! confirm_default_yes "Deseja configurar o remoto 'origin' agora?"; then
    echo -e "${YELLOW}‚Ñπ Remoto n√£o configurado.${NC}"
    return 0
  fi

  local input url kind
  read -rp "Informe a URL do remoto (SSH ou HTTPS): " input
  if [[ -z "$input" ]]; then
    echo -e "${RED}‚ùå URL vazia.${NC}"; return 1
  fi

  local parsed
  if ! parsed=$(detect_and_normalize_remote_url "$input"); then
    return 1
  fi
  kind="${parsed%%|*}"
  url="${parsed##*|}"

  # Pr√©-checa autentica√ß√£o conforme o tipo
  if [[ "$kind" == "ssh" ]]; then
    ensure_github_ssh_auth || true
  else
    ensure_github_https_auth || true
  fi

  git remote add origin "$url"
  echo -e "${GREEN}‚úî 'origin' => $url${NC}"

  echo -e "${CYAN}üîé Testando acesso ao remoto (git ls-remote)...${NC}"
  if git ls-remote --heads origin >/dev/null 2>&1; then
    echo -e "${GREEN}‚úî Acesso ao remoto OK.${NC}"
  else
    echo -e "${RED}‚ùå Falha ao acessar o remoto.${NC}"
    if [[ "$kind" == "ssh" ]]; then
      echo -e "   Verifique: chave adicionada no GitHub, agent ativo e permiss√µes da chave (~/.ssh, 600/700)."
    else
      echo -e "   Verifique: autentica√ß√£o via gh ou helper de credenciais + token v√°lido com escopo 'repo'."
    fi
    return 1
  fi

  # Se j√° temos commit, oferecer push -u
  if git rev-parse HEAD >/dev/null 2>&1; then
    local branch_current
    branch_current="$(git branch --show-current)"
    if confirm_default_yes "Deseja definir upstream (git push -u origin ${branch_current})?"; then
      if git push -u origin "$branch_current"; then
        echo -e "${GREEN}‚úî Upstream configurado.${NC}"
      else
        echo -e "${YELLOW}‚ö† N√£o foi poss√≠vel fazer push agora.${NC}"
      fi
    fi
  fi
}


confirm_default_yes() {
  local prompt="$1"
  read -rp "$prompt (S/n): " resp
  [[ -z "$resp" || "$resp" =~ ^[sS]$ ]]
}

check_dependencies() {
  if ! command -v jq >/dev/null 2>&1 || ! command -v git >/dev/null 2>&1; then
    echo -e "${RED}‚ùå Requer o utilit√°rio 'jq' e 'git'. Instale com: sudo apt install jq git${NC}"
    exit 1
  fi
}

migrate_config() {
  local local_config="$1"
  local global_config="$2"

  if [[ ! -f "$global_config" ]]; then
    # N√£o √© poss√≠vel migrar se a fonte da verdade estiver faltando
    return
  fi

  # Mescla a configura√ß√£o global com a local. As chaves da configura√ß√£o local t√™m preced√™ncia.
  local merged_json
  # A adi√ß√£o do '|| true' previne que o script pare caso o jq falhe (importante por causa do 'set -e')
  merged_json=$(jq -s '.[1] + .[0]' "$local_config" "$global_config" 2>/dev/null) || true

  # Apenas sobrescreve se o jq teve sucesso (sa√≠da n√£o vazia)
  if [[ -n "$merged_json" ]]; then
    echo "$merged_json" > "$local_config"
  fi
}

load_config() {
  local project_config_file="$WORK_DIR/.comitar.json"
  local global_config_source="$COMITAR_INSTALL_ROOT/config/comitar.json"
  local git_root

  # Determina o caminho do arquivo de configura√ß√£o, preferindo a raiz do git, se dispon√≠vel
  if check_git_repo_silent; then
    git_root=$(git rev-parse --show-toplevel)
    project_config_file="$git_root/.comitar.json"
  fi

  # Se um arquivo de configura√ß√£o existir no caminho determinado, use-o e migre-o.
  if [[ -f "$project_config_file" ]]; then
    CONFIG_FILE="$project_config_file"
    migrate_config "$CONFIG_FILE" "$global_config_source"
  # Se n√£o houver arquivo de configura√ß√£o, mas estivermos em um reposit√≥rio git, crie um a partir do modelo.
  elif check_git_repo_silent; then
    echo -e "${YELLOW}‚ö† Arquivo de configura√ß√£o local '$project_config_file' n√£o encontrado. Copiando do padr√£o...${NC}"
    cp "$global_config_source" "$project_config_file"
    echo -e "${GREEN}‚úî Arquivo de configura√ß√£o copiado para '$project_config_file'.${NC}"
    CONFIG_FILE="$project_config_file"
  else
    # N√£o est√° em um reposit√≥rio git e nenhum .comitar.json no diret√≥rio atual.
    echo -e "${RED}‚ùå Arquivo de configura√ß√£o '.comitar.json' n√£o encontrado.${NC}"
    echo -e "${YELLOW}üí° Execute 'comitar' dentro de um reposit√≥rio Git para criar um automaticamente.${NC}"
    exit 1
  fi

  # Garante que .comitar.json esteja no .gitignore se estiver em um reposit√≥rio git
  if check_git_repo_silent; then
    if ! grep -q ".comitar.json" "$git_root/.gitignore" 2>/dev/null; then
      echo -e "\n# Comitar config file\n.comitar.json" >> "$git_root/.gitignore"
      echo -e "${GREEN}‚úî '.comitar.json' adicionado ao .gitignore.${NC}"
    fi
  fi

  CHANGELOG_FILE=$(jq -r '.changelog_path' "$CONFIG_FILE")
}

check_git_repo() {
  git rev-parse --is-inside-work-tree &>/dev/null || {
    printf "${RED}‚ùå Esse diret√≥rio n√£o √© um reposit√≥rio Git.${NC}\n"
    exit 1
  }
}

install_hook() {
  check_git_repo
  local hook_path=".git/hooks/commit-msg"
  if [[ ! -f "$COMMIT_HOOK_SCRIPT" ]]; then
      printf "${RED}‚ùå Arquivo de valida√ß√£o n√£o encontrado:${NC} $COMMIT_HOOK_SCRIPT\n"
      printf "Atualize o comitar com 'comitar --upgrade'\n"
      exit 1
  fi

  if [[ ! -f "$hook_path" ]]; then
      cp "$COMMIT_HOOK_SCRIPT" "$hook_path"
      chmod +x "$hook_path"
      printf "${GREEN}‚úî Hook instalado com sucesso:${NC} .git/hooks/commit-msg\n"
  fi
}

check_and_update_version() {
  local version_control
  version_control=$(jq -r '.version_control // false' "$CONFIG_FILE")
  [[ "$version_control" != "true" ]] && return

  mapfile -t version_targets < <(jq -c '.version_targets[]?' "$CONFIG_FILE")

  if [[ ${#version_targets[@]} -eq 0 ]]; then
    local control_file
    control_file=$(jq -r '.control_file // ""' "$CONFIG_FILE")
    if [[ -z "$control_file" ]]; then return; fi
    local var_name
    var_name=$(jq -r '.var_name // ""' "$CONFIG_FILE")
    version_targets+=("$(jq -c --arg file "$control_file" --arg var "$var_name" '{file: $file, var_name: $var}' <<< '')")
  fi

  local source_target="${version_targets[0]}"
  local source_file
  source_file=$(jq -r '.file' <<< "$source_target")
  local source_var
  source_var=$(jq -r '.var_name' <<< "$source_target")

  if [[ ! -f "$source_file" ]]; then
    echo -e "${RED}‚ùå Arquivo de vers√£o fonte n√£o encontrado: $source_file${NC}"
    return
  fi

  local current_version
  if [[ -n "$source_var" ]]; then
    current_version=$(grep -E "^\s*${source_var}" "$source_file" | sed -E 's/.*[=:\"]+[[:space:]]*//; s/"//g')
  else
    current_version=$(cat "$source_file" | tr -d '[:space:]')
  fi

  if [[ -z "$current_version" ]]; then
    echo -e "${RED}‚ùå N√£o foi poss√≠vel ler a vers√£o atual do arquivo '$source_file'${NC}"
    return
  fi

  echo -e "${CYAN}Vers√£o atual em $source_file: $current_version${NC}"
  read -rp "Deseja alterar a vers√£o antes do commit? (s/n): " change_version
  if [[ -z "$change_version" || "$change_version" =~ ^[sS]$ ]]; then
    local version_core
    local build
    if [[ "$current_version" == *"+"* ]]; then
        version_core=$(echo "$current_version" | cut -d+ -f1)
        build=$(echo "$current_version" | cut -d+ -f2)
    else
        version_core="$current_version"
        build=0
    fi

    local major minor patch
    major=$(echo "$version_core" | cut -d. -f1)
    minor=$(echo "$version_core" | cut -d. -f2)
    patch=$(echo "$version_core" | cut -d. -f3)

    # Sanitize version parts to allow only integers for arithmetic operations
    major=${major//[^0-9]/}
    minor=${minor//[^0-9]/}
    patch=${patch//[^0-9]/}

    major=${major:-0}
    minor=${minor:-0}
    patch=${patch:-0}

    local version_build_config
    version_build_config=$(jq -r '.version_build // false' "$CONFIG_FILE")

    echo -e "${BOLD}Escolha o tipo de altera√ß√£o:${NC}"
    echo "1. feat: Novo recurso (minor +1)"
    echo "2. fix: Corre√ß√£o de bug (patch +1)"
    echo "3. refactor: Refatora√ß√£o (patch +1)"
    echo "4. rebuild: Apenas rebuild (build +1)"
    echo "5. ajuste manual"
    echo "6. manter vers√£o atual: $current_version"
    echo "0. cancelar"
    read -rp "Qual a altera√ß√£o deseja: " choose_change

    local new_version=""
    case "$choose_change" in
      1) minor=$((minor + 1)); patch=0; build=1 ;;
      2|3) patch=$((patch + 1)); build=1 ;;
      4) build=$((build + 1)) ;;
      5)
        read -rp "Digite a nova vers√£o completa (ex: 1.5.3 ou 1.5.3+2): " man_new_version
        if [[ "$man_new_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(\+[0-9]+)?$ ]]; then
          new_version="$man_new_version"
        else
          echo -e "${RED}‚ùå Formato inv√°lido.${NC}"
          return
        fi
        ;;
      6) new_version="$current_version" ;;
      0) echo -e "${YELLOW}‚ö†Ô∏è Opera√ß√£o cancelada.${NC}"; return ;;
      *) echo -e "${RED}‚ùå Escolha inv√°lida.${NC}"; return ;;
    esac

    if [[ -z "$new_version" ]]; then
        if [[ "$version_build_config" == "true" ]]; then
            new_version="${major}.${minor}.${patch}+${build}"
        else
            new_version="${major}.${minor}.${patch}"
        fi
    fi

    echo -e "${GREEN}‚úî Vers√£o ser√° atualizada para: $new_version${NC}"
    for target in "${version_targets[@]}"; do
      local target_file
      target_file=$(jq -r '.file' <<< "$target")
      local target_var
      target_var=$(jq -r '.var_name' <<< "$target")

      if [[ ! -f "$target_file" ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Arquivo alvo n√£o encontrado, pulando: $target_file${NC}"
        continue
      fi

      if [[ -n "$target_var" ]]; then
        local safe_var
        safe_var=$(printf '%s\n' "$target_var" | sed -e 's/[][().*^$+{}?|\\]/\\&/g')
        #sed -i -E "s/^(\s*${target_var}\s*[:=]\s*['"]?).*(['"]?)$/\1${new_version}\2/" "$target_file"
        sed -i -E 's/^([[:space:]]*'"$safe_var"'[[:space:]]*[:=][[:space:]]*['"'"'"]?).*(['"'"'"]?)$/\1'"$new_version"'\2/' "$target_file"
      else
        sed -i "1s/.*/$new_version/" "$target_file"
      fi
      echo -e "${GREEN}  -> Arquivo '$target_file' atualizado.${NC}"
      echo -e "${GREEN}‚úî Vers√£o atualizada para: $new_version${NC}"
    done
  fi
}


show_default_commit_types() {
  echo -e "${BLUE}Tipos de commit padr√£o:${NC}"
  echo " 0. cancelar:  ‚ùå"
  mapfile -t default_options < <(jq -c '.default_types[]?' "$CONFIG_FILE")
  for i in "${!default_options[@]}"; do
    item="${default_options[$i]}"
    type=$(jq -r '.type' <<< "$item")
    emoji=$(jq -r '.emoji' <<< "$item")
    label=$(jq -r '.label' <<< "$item")
    printf "%2d. %-10s %s %s\n" "$((i+1))" "$type:" "$emoji" "$label"
  done
  echo -e "${CYAN}${BLINK}99.${NC} Mostrar tipos personalizados ‚è¨"
}

show_commit_menu() {
  echo -e "${BLUE}${BOLD}Selecione o tipo de commit:${NC}"
  echo
  show_default_commit_types
  echo
  read -rp "Selecione o tipo: " type_num
  case $type_num in
    0 | [qQ] | [sS])
      echo -e "${YELLOW}${BLINK} ‚ö†Ô∏è COMMIT Cancelado pelo usu√°rio.${NC}"
      exit 0
      ;;
    99)
      echo -e "\n${BLUE}Tipos adicionais definidos em comitar.config:${NC}"
      mapfile -t options < <(jq -c '.custom_types[]?' "$CONFIG_FILE")
      for i in "${!options[@]}"; do
        item="${options[$i]}"
        type=$(jq -r '.type' <<< "$item")
        emoji=$(jq -r '.emoji' <<< "$item")
        label=$(jq -r '.label' <<< "$item")
        printf "%2d. %-10s %s %s\n" "$((i+1+${#default_options[@]}))" "$type:" "$emoji" "$label"
      done
      echo
      read -rp "Digite o n√∫mero do tipo adicional: " extra_type_num
      case "$extra_type_num" in
        0 | [sS]| [qQ] | sair | SAIR)
          echo -e "${YELLOW}${BLINK} ‚ö†Ô∏è Commit cancelado pelo usu√°rio.${NC}"
          exit 0
          ;;
        [vV] | voltar)
          echo -e "${CYAN}‚Ü©Ô∏è  Retornando ao menu principal...${NC}"
          show_commit_menu
          return
          ;;
      esac
      offset=$((extra_type_num - ${#default_options[@]} - 1))
      if [[ "$extra_type_num" =~ ^[0-9]+$ ]] && (( offset >= 0 && offset < ${#options[@]} )); then
        selected="${options[$offset]}"
      else
        echo -e "${RED}${BLINK}‚ùå Tipo inv√°lido.${NC}"
        exit 1
      fi
      ;;
    *)
      if [[ "$type_num" =~ ^[0-9]+$ ]] && (( type_num > 0 && type_num <= ${#default_options[@]} )); then
        selected="${default_options[$((type_num-1))]}"
      else
        echo -e "${RED}${BLINK}‚ùå Tipo inv√°lido.${NC}"
        exit 1
      fi
    ;;
  esac
  tipo=$(jq -r '.type' <<< "$selected")
  emoji=$(jq -r '.emoji' <<< "$selected")
  label=$(jq -r '.label' <<< "$selected")
}


get_commit_message() {
  local use_scope_config=$(jq -r '.use_scope' "$CONFIG_FILE")
  local scope=""

  while true; do
    echo -e " ‚Ü™Ô∏è Tipo selecionado: $tipo $emoji"
    if [[ "$use_scope_config" == "true" ]]; then
      read -rp "   ‚úèÔ∏è  Digite o escopo do commit (opcional, ex: auth, ui): " scope
    fi
    read -rp "   ‚úèÔ∏è  Digite a mensagem do commit: " mensagem
    case "$mensagem" in
      [vV] | voltar | VOLTAR)
        echo -e "${YELLOW}‚Ü©Ô∏è  Retornando ao menu de sele√ß√£o de tipo...${NC}"
        show_commit_menu
        mensagem=""
        get_commit_message
        return
        ;;
      [sS] | sair | SAIR)
        echo -e "${YELLOW}${BLINK}‚ö†Ô∏è Commit cancelado pelo usu√°rio.${NC}"
        exit 0
        ;;
      *)
        if [[ -n "$mensagem" ]]; then
          break
        else
          echo -e "${RED}‚ö†Ô∏è A mensagem n√£o pode estar vazia.${NC}"
        fi
        ;;
    esac
  done
  # Armazena o escopo para uso posterior
  COMMIT_SCOPE="$scope"

  # Captura o corpo do commit (descri√ß√£o longa)
  COMMIT_BODY=""
  local use_body_config
  use_body_config=$(jq -r '.use_commit_body // false' "$CONFIG_FILE")
  if [[ "$use_body_config" == "true" ]]; then
    echo -e "   üí¨  Digite a descri√ß√£o longa (corpo do commit). Pressione Enter para nova linha."
    echo -e "      Digite ${BOLD}FIM${NC} em uma linha nova para concluir."
    local body_lines=""
    while IFS= read -r line; do
        if [[ "$line" == "FIM" ]]; then
            break
        fi
        body_lines+="$line\n"
    done
    # Remove a √∫ltima quebra de linha adicionada
    COMMIT_BODY=$(echo -e "${body_lines%\n}")
  fi
}

interactive_add() {
    echo -e "${BLUE}${BOLD}Selecione os arquivos para adicionar ao commit:${NC}"

    local files_to_add=()
    local display_lines=()
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        display_lines+=("$line")
        # Handle renames like 'R  old -> new'
        if [[ "$line" =~ "^R[[:space:]]+.*[[:space:]]->[[:space:]]" ]]; then
            # Extract the 'new' part
            files_to_add+=("$(echo "$line" | sed 's/.* -> //')")
        else
            # For other statuses, just get the path after the status chars
            files_to_add+=("$(echo "$line" | cut -c4-)")
        fi
    done < <(git status --porcelain)

    if [ ${#files_to_add[@]} -eq 0 ]; then
        echo -e "${YELLOW}Nenhum arquivo alterado para commitar.${NC}"
        return
    fi

    for i in "${!display_lines[@]}"; do
        printf "%2d. %s\n" "$((i+1))" "${display_lines[$i]}"
    done
    echo ""
    echo -e "Digite os n√∫meros dos arquivos separados por espa√ßo (ex: 1 3 4)."
    echo -e "Ou digite 'a' para adicionar todos, 'q' para cancelar."
    read -rp "Arquivos para adicionar: " selection

    if [[ "$selection" =~ ^[aA]$ ]]; then
        git add -A
        echo -e "${GREEN}‚úî Todos os arquivos alterados foram adicionados.${NC}"
        return
    fi

    if [[ "$selection" =~ ^[qQ]$ ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è Nenhum arquivo adicionado. Commit cancelado.${NC}"
        exit 1
    fi

    local added_count=0
    for num in $selection; do
        if [[ "$num" =~ ^[0-9]+$ ]]; then
            local index=$((num-1))
            if [[ $index -ge 0 && $index -lt ${#files_to_add[@]} ]]; then
                git add "${files_to_add[$index]}"
                echo -e "${GREEN}  -> Adicionado: ${files_to_add[$index]}${NC}"
                ((added_count++))
            else
                echo -e "${RED}‚ùå N√∫mero inv√°lido: $num${NC}"
            fi
        else
            if [[ -n "$num" ]]; then
              echo -e "${RED}‚ùå Entrada inv√°lida: '$num'. Por favor, use n√∫meros.${NC}"
            fi
        fi
    done

    if [[ $added_count -eq 0 ]]; then
        echo -e "${RED}‚ùå Nenhum arquivo v√°lido selecionado. Commit cancelado.${NC}"
        exit 1
    fi
}

generate_commit() {
  local use_emojis_config=$(jq -r '.use_emojis' "$CONFIG_FILE")
  local use_scope_config=$(jq -r '.use_scope' "$CONFIG_FILE")
  local commit_prefix=""
  local commit_scope_formatted=""

  if [[ "$use_emojis_config" == "true" ]]; then
    commit_prefix=":$emoji: "
  fi

  if [[ "$use_scope_config" == "true" ]] && [[ -n "$COMMIT_SCOPE" ]]; then
    commit_scope_formatted="($COMMIT_SCOPE)"
  fi

  commit_final="${commit_prefix}${tipo}${commit_scope_formatted}: ${mensagem}"
  echo -e "${BLUE}Commit final:${NC} $commit_final"
  if [[ -n "$COMMIT_BODY" ]]; then
    echo -e "${BLUE}Corpo:${NC}\n$COMMIT_BODY"
  fi

  generate_changelog
  [[ -n "$CHANGELOG_FILE" && -f "$CHANGELOG_FILE" ]] && git add "$CHANGELOG_FILE"

  local add_all_files
  add_all_files=$(jq -r '.add_all_files // true' "$CONFIG_FILE")

  if [[ "$add_all_files" == "true" ]]; then
    git add -A
  else
    interactive_add
  fi

  # Verifica se h√° algo para commitar
  if git diff --staged --quiet; then
    echo -e "${YELLOW}‚ö†Ô∏è Nenhum arquivo foi selecionado para o commit. Opera√ß√£o cancelada.${NC}"
    exit 1
  fi

  local commit_args=()
  commit_args+=("-m" "$commit_final")
  if [[ -n "$COMMIT_BODY" ]]; then
    commit_args+=("-m" "$COMMIT_BODY")
  fi

  if git commit "${commit_args[@]}"; then
    echo -e "${GREEN}‚úî Commit realizado com sucesso.${NC}"
    ask_tags
    ask_push
  else
    echo -e "${RED}‚ùå Falha ao realizar commit.${NC}"
  fi
}

generate_changelog() {
  if jq -e '.generate_changelog' "$CONFIG_FILE" | grep -q true; then
    local user_name
    user_name=$(git config user.name)
    echo "- :$emoji: $tipo: $mensagem (por: $user_name em $(date +'%d-%m-%Y %H:%M'))" >> "$CHANGELOG_FILE"
    echo -e "${GREEN}‚úî Changelog atualizado em $CHANGELOG_FILE${NC}"
  fi
}

send_tags_push() {
  read -rp "üè∑Ô∏è Deseja enviar as tags? (s/n): " confirm_send
  if [[ -z "$confirm_send" || "$confirm_send" =~ ^[sS]$ ]]; then
    git push --tags && printf "${GREEN}‚úî Tags enviadas com sucesso.${NC}\n" || printf "${RED}‚ùå Falha ao enviar tags.${NC}\n"
  fi
}

ask_tags() {
  local control_tag
  local send_tags=false

  control_tag=$(jq -r '.control_tag // false' "$CONFIG_FILE")
  [[ "$control_tag" != "true" ]] && return

  read -rp "üè∑Ô∏è Deseja criar uma tag agora? (s/n): " confirm_tag
  if [[ -z "$confirm_tag" || "$confirm_tag" =~ ^[sS]$ ]]; then
    send_tags=true
    read -rp "Digite o nome da tag desejada: " use_tag
    git tag "$use_tag" && printf "${GREEN}‚úî Tag '$use_tag' criada.\n${NC}" || printf "${RED}‚ùå Falha ao criar tag.\n${NC}"
    if [[ -z "$use_tag" ]]; then
      echo -e "${RED}‚ùå Nome da tag n√£o pode ser vazio.${NC}"
      return
    fi
  fi

  if $send_tags; then
    send_tags_push
  else
    printf "${RED}‚ùå Falha ao criar tag (talvez '$use_tag' j√° exista?).\n${NC}"
    return
  fi
}

ask_push() {
  local default_push_config
  default_push_config=$(jq -r '.default_push // false' "$CONFIG_FILE")
  local ask_push_config
  ask_push_config=$(jq -r '.ask_push // true' "$CONFIG_FILE")

  # Se o push autom√°tico estiver ativado, fa√ßa o push e saia.
  if [[ "$default_push_config" == "true" ]]; then
    echo -e "${CYAN}üöÄ Realizando push autom√°tico (configurado em .comitar.json)...${NC}"
    local branch_current
    branch_current=$(git branch --show-current)
    if git rev-parse --abbrev-ref --symbolic-full-name @{u} >/dev/null 2>&1; then
      git push && echo -e "${GREEN}‚úî Push realizado com sucesso.${NC}"
    else
      git push -u origin "$branch_current" && echo -e "${GREEN}‚úî Push realizado com sucesso.${NC}"
    fi
    return
  fi

  # Se o push autom√°tico estiver desativado, verifique se devemos perguntar.
  if [[ "$ask_push_config" == "true" ]]; then
    read -rp "‚§¥Ô∏è Deseja fazer push agora? (s/n): " confirm
    if [[ -z "$confirm" || "$confirm" =~ ^[sS]$ ]]; then
      local branch_current
      branch_current=$(git branch --show-current)
      if git rev-parse --abbrev-ref --symbolic-full-name @{u} >/dev/null 2>&1; then
        git push && echo -e "${GREEN}‚úî Push realizado com sucesso.${NC}"
      else
        git push -u origin "$branch_current" && echo -e "${GREEN}‚úî Push realizado com sucesso.${NC}"
      fi
    else
      echo -e "${YELLOW}‚ö† Push n√£o realizado. Execute manualmente se desejar.${NC}"
    fi
  fi
  # Se ask_push_config for false, a fun√ß√£o simplesmente termina sem fazer nada.
}

show_comitar_news() {
  local changelog_script="$COMITAR_INSTALL_ROOT/tools/changelog.sh"
  if [[ -d "$COMITAR_INSTALL_ROOT/.git" ]]; then
    (cd "$COMITAR_INSTALL_ROOT" && "$changelog_script")
  else
    echo -e "${RED}‚ùå Instala√ß√£o do Comitar via Git n√£o encontrada em $COMITAR_INSTALL_ROOT${NC}"
    echo -e "${YELLOW}üí° O comando 'news' requer que o Comitar seja instalado com a vers√£o mais recente do instalador.${NC}"
    exit 1
  fi
}

configure_comitar() {
  echo -e "${BLUE}${BOLD}Configura√ß√£o do Comitar${NC}"
  echo ""
  load_config

  # Configurar uso de cores
  current_colors=$(jq -r '.use_colors' "$CONFIG_FILE")
  read -rp "Usar cores nas mensagens? (s/n) [atual: $([[ "$current_colors" == "true" ]] && echo "sim" || echo "n√£o")]: " choice
  if [[ -z "$choice" || "$choice" =~ ^[sS]$ ]]; then
    jq '.use_colors = true' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  elif [[ "$choice" =~ ^[nN]$ ]]; then
    jq '.use_colors = false' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  fi

  # Configurar uso de efeito pisca
  current_blinks=$(jq -r '.use_blinks' "$CONFIG_FILE")
  read -rp "Usar efeito pisca nas mensagens? (s/n) [atual: $([[ "$current_blinks" == "true" ]] && echo "sim" || echo "n√£o")]: " choice
  if [[ -z "$choice" || "$choice" =~ ^[sS]$ ]]; then
    jq '.use_blinks = true' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  elif [[ -z "$choice" || "$choice" =~ ^[nN]$ ]]; then
    jq '.use_blinks = false' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  fi

  # Configurar uso de emojis
  current_emojis=$(jq -r '.use_emojis' "$CONFIG_FILE")
  read -rp "Usar emojis nos commits? (s/n) [atual: $([[ "$current_emojis" == "true" ]] && echo "sim" || echo "n√£o")]: " choice
  if [[ -z "$choice" || "$choice" =~ ^[sS]$ ]]; then
    jq '.use_emojis = true' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  elif [[ "$choice" =~ ^[nN]$ ]]; then
    jq '.use_emojis = false' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  fi

  # Configurar uso de escopo
  current_scope=$(jq -r '.use_scope' "$CONFIG_FILE")
  read -rp "Usar escopo nos commits (ex: feat(auth):)? (s/n) [atual: $([[ "$current_scope" == "true" ]] && echo "sim" || echo "n√£o")]: " choice
  if [[ -z "$choice" || "$choice" =~ ^[sS]$ ]]; then
    jq '.use_scope = true' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  elif [[ "$choice" =~ ^[nN]$ ]]; then
    jq '.use_scope = false' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  fi

  # Configurar adi√ß√£o de todos os arquivos
  current_add_all=$(jq -r '.add_all_files // true' "$CONFIG_FILE")
  read -rp "Adicionar todos os arquivos automaticamente (git add -A)? (s/n) [atual: $([[ "$current_add_all" == "true" ]] && echo "sim" || echo "n√£o")]: " choice
  if [[ -z "$choice" || "$choice" =~ ^[sS]$ ]]; then
    jq '.add_all_files = true' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  elif [[ "$choice" =~ ^[nN]$ ]]; then
    jq '.add_all_files = false' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  fi

  # Configurar controle de tags
  current_control_tag=$(jq -r '.control_tag // false' "$CONFIG_FILE")
  read -rp "Controlar tags automaticamente ap√≥s o commit? (s/n) [atual: $([[ "$current_control_tag" == "true" ]] && echo "sim" || echo "n√£o")]: " choice
  if [[ -z "$choice" || "$choice" =~ ^[sS]$ ]]; then
    jq '.control_tag = true' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  elif [[ "$choice" =~ ^[nN]$ ]]; then
    jq '.control_tag = false' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  fi

  # Configurar controle de vers√£o autom√°tico
  current_control_version=$(jq -r '.version_control // false' "$CONFIG_FILE")
  read -rp "Controlar vers√£o automaticamente? (s/n) [atual: $([[ "$current_control_version" == "true" ]] && echo "sim" || echo "n√£o")]: " choice

  if [[ "$choice" =~ ^[nN]$ ]]; then
    jq '.version_control = false' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
    echo -e "${YELLOW}‚ÑπÔ∏è Controle de vers√£o desativado.${NC}"
  elif [[ -z "$choice" || "$choice" =~ ^[sS]$ ]]; then
    # Ativa o controle e limpa a lista de alvos para come√ßar do zero.
    jq '.version_control = true | .version_targets = []' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
    echo -e "${CYAN}Configurando alvos de versionamento. O primeiro que voc√™ adicionar ser√° a 'fonte da verdade'.${NC}"
    echo -e "${CYAN}Pressione Enter em um campo de arquivo vazio para parar de adicionar.${NC}"

    while true; do
      echo ""
      read -rp "Caminho do arquivo alvo (ex: VERSION, package.json): " input_file
      if [[ -z "$input_file" ]]; then
        break
      fi

      read -rp "Nome da vari√°vel no arquivo (deixe em branco se n√£o houver): " input_var

      jq --arg file "$input_file" --arg var "$input_var" '.version_targets += [{file: $file, var_name: $var}]' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
      echo -e "${GREEN}‚úî Alvo adicionado: $input_file ($input_var)${NC}"
    done

    # Flag extra: controlar build separadamente?
    current_build=$(jq -r '.version_build // false' "$CONFIG_FILE")
    read -rp "Controlar n√∫mero de build separadamente (ex: 1.2.3+1)? (s/n) [atual: $([[ "$current_build" == "true" ]] && echo "sim" || echo "n√£o")]: " input_build
    if [[ -z "$input_build" || "$input_build" =~ ^[sS]$ ]]; then
      jq '.version_build = true' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
    elif [[ "$input_build" =~ ^[nN]$ ]]; then
      jq '.version_build = false' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
    fi
  fi

  echo -e "${GREEN}‚úî Configura√ß√£o atualizada com sucesso!${NC}"
}

undo_last_commit() {
  check_git_repo

  local last_commit_hash=$(git rev-parse HEAD)
  local last_commit_msg=$(git log -1 --pretty=format:"%s")

  echo -e "${YELLOW}‚ö† √öltimo commit:${NC} $last_commit_msg"

  if git status | grep -q "Your branch is ahead of"; then
    echo -e "${BLUE}Commit ainda n√£o enviado para o remoto.${NC}"
    read -rp "Deseja desfazer o √∫ltimo commit (manter arquivos)? (s/n): " confirm
    if [[ -z "$confirm" || "$confirm" =~ ^[sS]$ ]]; then
      git reset --soft HEAD~1
      echo -e "${GREEN}‚úî Commit desfeito localmente (arquivos mantidos no stage).${NC}"
    fi
  else
    echo -e "${RED}Commit j√° foi enviado para o remoto.${NC}"
    read -rp "Deseja reverter com 'git revert'? (s/n): " confirm
    if [[ -z "$confirm" || "$confirm" =~ ^[sS]$ ]]; then
      git revert "$last_commit_hash"
      echo -e "${GREEN}‚úî Commit revertido com sucesso.${NC}"
    fi
  fi

  # Verifica se existe uma tag associada ao commit
  tag=$(git tag --contains "$last_commit_hash")
  if [[ -n "$tag" ]]; then
    echo -e "${YELLOW}üè∑Ô∏è Tag associada encontrada: ${tag}${NC}"
    read -rp "Deseja apagar essa tag local e remotamente? (s/n): " delete_tag
    if [[ -z "$delete_tag" || "$delete_tag" =~ ^[sS]$ ]]; then
      git tag -d "$tag"
      git push origin ":refs/tags/$tag"
      echo -e "${GREEN}‚úî Tag removida local e remotamente.${NC}"
    fi
  fi
}

check_for_updates() {
    # Do not check for updates if running inside a CI environment
    if [[ -n "$CI" ]]; then
        return
    fi

    local last_check_file="$COMITAR_INSTALL_ROOT/.last_update_check"
    local today
    today=$(date +%Y-%m-%d)

    # Check if we already prompted today
    if [[ -f "$last_check_file" ]] && [[ "$(cat "$last_check_file")" == "$today" ]]; then
        return
    fi

    # Fetch remote version - timeout after 2 seconds to not slow down the user
    local remote_version
    remote_version=$(curl -fsSL --max-time 2 "https://raw.githubusercontent.com/ketteiGustavo/comitar/main/VERSION" 2>/dev/null || echo "")

    # Write timestamp to not check again today, even if fetch fails
    echo "$today" > "$last_check_file"

    # If fetch failed or version is same, do nothing.
    if [[ -z "$remote_version" ]] || [[ "$remote_version" == "$APP_VERSION" ]]; then
        return
    fi

    # If we are here, there's a new version. Prompt the user.
    echo -e "\n${YELLOW}üí° Uma nova vers√£o do Comitar est√° dispon√≠vel: ${GREEN}$remote_version${NC} (voc√™ tem a ${RED}$APP_VERSION${NC})"
    read -rp "   Deseja atualizar agora? (S/n): " choice

    if [[ -z "$choice" || "$choice" =~ ^[sS]$ ]]; then
        echo -e "${CYAN}üöÄ Atualizando...${NC}"
        # Execute the upgrade script
        "$UPGRADE_SCRIPT"
        echo -e "\n${GREEN}‚úÖ Comitar atualizado! Por favor, execute seu comando novamente.${NC}"
        # Exit so the user doesn't run their original command with the old version
        exit 0
    fi
}

init_repo() {
  check_dependencies
  ensure_git_identity

  # 1) Se n√£o for repo, inicializa com branch padr√£o (global ou main)
  if ! check_git_repo_silent; then
    local default_branch
    default_branch="$(git config --global init.defaultBranch 2>/dev/null || true)"
    [[ -z "$default_branch" ]] && default_branch="main"
    git init -b "$default_branch"
    echo -e "${GREEN}‚úî Git inicializado (branch: ${default_branch}).${NC}"
  fi

  # 2) Nome do projeto (pelo diret√≥rio atual)
  local project_name
  project_name="$(basename "$WORK_DIR")"

  # 3) Cria README se n√£o existir
  if [[ ! -f README.md ]]; then
    echo " # ${project_name}" >> README.md
    echo -e "${GREEN}‚úî README.md criado.${NC}"
  else
    echo -e "${YELLOW}‚Ñπ README.md j√° existe; mantendo como est√°.${NC}"
  fi

  # 4) .gitignore m√≠nimo para .comitar.json
  if [[ ! -f ".gitignore" ]]; then
    echo "# Comitar config file" > .gitignore
    echo ".comitar.json" >> .gitignore
    echo -e "${GREEN}‚úî .gitignore criado.${NC}"
  else
    grep -qE '(^|/)\.comitar\.json$' .gitignore || { echo ".comitar.json" >> .gitignore; echo -e "${GREEN}‚úî '.comitar.json' adicionado ao .gitignore.${NC}"; }
  fi

  # 5) Commit inicial se ainda n√£o houver commits
  if ! git rev-parse --verify HEAD >/dev/null 2>&1; then
    git add -A
    if ! git diff --cached --quiet; then
      git commit -m "chore: initial commit"
      echo -e "${GREEN}‚úî Commit inicial criado.${NC}"
    else
      echo -e "${YELLOW}‚Ñπ Nada para commitar no momento.${NC}"
    fi
  else
    echo -e "${YELLOW}‚Ñπ Reposit√≥rio j√° possui hist√≥rico; n√£o cria commit inicial.${NC}"
  fi

  # 6) Configura remoto 'origin' (se ainda n√£o houver) e push -u
  if ! git config --get remote.origin.url >/dev/null 2>&1; then
    echo -e "${CYAN}üîó Vamos configurar o remoto 'origin'.${NC}"
    configure_remote_origin || {
      echo -e "${YELLOW}‚ö† N√£o foi poss√≠vel configurar o remoto agora.${NC}"
      return 0
    }
  else
    echo -e "${GREEN}‚úî Remoto 'origin' j√° configurado.${NC}"
  fi

  # 7) Push -u se upstream n√£o estiver definido
  local branch_current
  branch_current="$(git branch --show-current)"
  if ! git rev-parse --abbrev-ref --symbolic-full-name @{u} >/dev/null 2>&1; then
    echo -e "${CYAN}‚§¥Ô∏è  Enviando branch '${branch_current}' e definindo upstream...${NC}"
    if git push -u origin "$branch_current"; then
      echo -e "${GREEN}‚úî Push realizado e upstream definido.${NC}"
    else
      echo -e "${YELLOW}‚ö† Falha no push. Verifique autentica√ß√£o e permiss√µes.${NC}"
    fi
  else
    echo -e "${YELLOW}‚Ñπ Upstream j√° definido para '${branch_current}'.${NC}"
  fi

  # 8) Ajustes do Comitar (config e hook) ‚Äì opcionais mas √∫teis
  load_config
  test_colors
  install_hook || true
  echo -e "${GREEN}‚úÖ Reposit√≥rio pronto!${NC}"
}


main() {
  # List of commands that should not trigger the update check
  local no_update_check_commands="--upgrade --version news --news --help -h --init init"
  if ! echo "$no_update_check_commands" | grep -q -- "$1"; then
      check_for_updates
  fi

  case "${1:-}" in
    --init | init) init_repo ;;
    --install-hook) install_hook ;;
    --help | -h) show_help ;;
    --version | -V) show_version ;;
    --config | -c) configure_comitar ;;
    --undo) undo_last_commit ;;
    changelog|--changelog) "$CHANGELOG_SCRIPT" "${@:2}" ;;
    --uninstall) "$UNINSTALL_SCRIPT" ;;
    --upgrade | -up | up) "$UPGRADE_SCRIPT" ;;
    news|--news) show_comitar_news ;;
    --commit | "")
      check_dependencies
      ensure_git_repo
      configure_remote_origin
      load_config
      test_colors
      install_hook
      show_commit_menu
      get_commit_message
      check_and_update_version
      generate_commit
      ;;
    *)
      printf "\n${RED}OP√á√ÉO '$1' DESCONHECIDA${NC}\n\n"
      printf "${YELLOW} ‚Ñπ Nenhuma op√ß√£o v√°lida informada.${NC}\n\n"
      show_help
      ;;
  esac
}

main "$@"
